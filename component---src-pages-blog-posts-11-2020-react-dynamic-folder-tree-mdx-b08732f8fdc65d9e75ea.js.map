{"version":3,"sources":["webpack:///./src/pages/blog/posts/11-2020/react-dynamic-folder-tree.mdx"],"names":["_frontmatter","layoutProps","MDXLayout","DefaultLayout","MDXContent","components","props","mdxType","parentName","isMDXComponent"],"mappings":"uPASaA,EAAe,GACtBC,EAAc,CAClBD,gBAEIE,EAAYC,IACH,SAASC,EAAT,GAGZ,IAFDC,EAEC,EAFDA,WACGC,EACF,8BACD,OAAO,YAACJ,EAAD,iBAAeD,EAAiBK,EAAhC,CAAuCD,WAAYA,EAAYE,QAAQ,cAI5E,gSAEA,6LAEA,uBAAK,kCAAMC,WAAW,OAAU,CAC5B,UAAa,wBADZ,8pBA8BL,2BAAU,0BAAYA,WAAW,KAAvB,YAAV,0HAAyL,0BAAYA,WAAW,KAAvB,UAAzL,cACA,uBAAK,kCAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,kPAUL,+HACA,mHAAkG,+BAAGA,WAAW,KAAQ,CACpH,KAAQ,oEADsF,eAAlG,yHAIA,wUAEA,uCAAsB,0BAAYA,WAAW,KAAvB,qBAAtB,+EACA,uBAAK,kCAAMA,WAAW,OAAU,CAC5B,UAAa,iBADZ,oXAoBL,qBAAG,0BAAYA,WAAW,KAAvB,uBAAH,kIAEA,uBAAK,kCAAMA,WAAW,OAAU,CAC5B,UAAa,iBADZ,gaAoBL,qFAAoE,0BAAYA,WAAW,KAAvB,qBAApE,yHAEA,mDAAkC,0BAAYA,WAAW,KAAvB,qBAAlC,iCACA,uBAAK,kCAAMA,WAAW,OAAU,CAC5B,UAAa,iBADZ,isBAiCL,gEACA,uBAAK,kCAAMA,WAAW,OAAU,CAC5B,UAAa,iBADZ,8mBA8BL,4BAAW,0BAAYA,WAAW,KAAvB,wBAAX,mJACA,uBAAK,kCAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,2oBA0BL,uJAAsI,0BAAYA,WAAW,KAAvB,mBAAtI,qBACO,0BAAYA,WAAW,KAAvB,oCADP,+BACmH,0BAAYA,WAAW,KAAvB,+CADnH,uDAEc,0BAAYA,WAAW,KAAvB,8BAFd,OAE4F,0BAAYA,WAAW,KAAvB,uCAF5F,KAGA,mCAAkB,0BAAYA,WAAW,KAAvB,wBAAlB,kCACA,uBAAK,kCAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,0ZAoBL,sDAAqC,0BAAYA,WAAW,KAAvB,wBAArC,mDACA,kDAAiC,0BAAYA,WAAW,KAAvB,uBAAjC,qCACA,uBAAK,kCAAMA,WAAW,OAAU,CAC5B,UAAa,iBADZ,ioBA2BL,gDAA+B,0BAAYA,WAAW,KAAvB,aAA/B,mDAAwI,0BAAYA,WAAW,KAAvB,aAAxI,+CACA,uBAAK,kCAAMA,WAAW,OAAU,CAC5B,UAAa,iBADZ,m4CAkDL,YAAC,IAAD,CAAkBD,QAAQ,qBAC1B,4MAMJH,EAAWK,gBAAiB","file":"component---src-pages-blog-posts-11-2020-react-dynamic-folder-tree-mdx-b08732f8fdc65d9e75ea.js","sourcesContent":["import * as React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\n\nimport DefaultLayout from \"/Users/shaminmeerankutty/Personal/shamin.github.io/src/components/markdown/post.tsx\";\nimport { AccordionExample } from \"../../../../components/posts/reactDynamicFolderTree\";\nexport const _frontmatter = {};\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout;\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n\n    <p>{`Recently I got a requirement for creating a folder tree in clojurescript which is dynamic that means we have to load the folder contents\ndynamically from an api when it is opened. I am going to explain how I did an initial version of it in javascript with React.`}</p>\n    <p>{`I started with a sample data in the structure I get. Also wrote a wrapper function which returns the folder contents when a directory is passed.\nIt look like this.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`const folder = {\n  \"/\": [\n    { name: \"documents\", dir: true },\n    { name: \"downloads\", dir: true },\n    { name: \"my.pptx\", dir: false },\n  ],\n  documents: [\n    { name: \"doc1.docx\", dir: false },\n    { name: \"pres.pptx\", dir: false },\n  ],\n  downloads: [\n    { name: \"music\", dir: true },\n    { name: \"file1.csv\", dir: false },\n    { name: \"file2.txt\", dir: false },\n  ],\n  \"downloads/music\": [\n    { name: \"doc1.docx\", dir: false },\n    { name: \"pres.pptx\", dir: false },\n  ],\n}\n\nexport default function getFolderContents(directory) {\n  return folder[directory].reduce((acc, cur) => {\n    acc[cur.name] = cur\n    return acc\n  }, {})\n}\n`}</code></pre>\n    <p>{`My `}<inlineCode parentName=\"p\">{`getFiles`}</inlineCode>{` function looks wierd this is because I wanted it in a tree like structure that way I can update it easily with lodash `}<inlineCode parentName=\"p\">{`update`}</inlineCode>{` function.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`/* This is what getFiles returns when '/' is passed as directory */\n\n{\n  \"documents\":  { name: \"documents\", dir: true },\n  \"downloads\":   { name: \"downloads\", dir: true },\n  \"my.pptx\"      :   { name: \"my.pptx\", dir: false },\n}\n`}</code></pre>\n    <p>{`Another reason why I went for this format is it is easier for me when I convert this to clojurescript.`}</p>\n    <p>{`Now I searched for some of the existing implementations of this feature and I could find a `}<a parentName=\"p\" {...{\n        \"href\": \"https://codyhouse.co/demo/multi-level-accordion-menu/index.html\"\n      }}>{`similar one`}</a>{` that suits my need. It was a css and vanila js\nimplementation. I decided to create a React component similar to it.`}</p>\n    <p>{`I had experience building accordion components. This new component works similar to accordion except that in this case there will be accordions inside accordion.\nSo, I started with an accordion component similar to what I did earlier. Also I have created accordion item component for files and folders.`}</p>\n    <p>{`This is how my `}<inlineCode parentName=\"p\">{`AccordionFileItem`}</inlineCode>{` component looks like. It is just a list item with an icon and a file name.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-jsx\"\n      }}>{`import React from \"react\"\nimport { Description } from \"@material-ui/icons\"\n\nfunction AccordionFileItem(props) {\n  return (\n    <li\n      className=\"accordion__item\"\n      onClick={e => {\n        e.stopPropagation()\n        props.onFileItemClick()\n      }}\n    >\n      <Description style={{ color: \"#fff\" }} />\n      {props.file.name}\n    </li>\n  )\n}\n`}</code></pre>\n    <p><inlineCode parentName=\"p\">{`AccordionFolderItem`}</inlineCode>{` was not straight forward because it will be having sub folders and files. I started with a folder item similar to\nfile item.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-jsx\"\n      }}>{`import React from \"react\"\nimport { Description } from \"@material-ui/icons\"\n\nfunction AccordionFolderItem(props) {\n  return (\n    <li\n      className=\"accordion__item accordion__item--folder\"\n      onClick={e => {\n        e.stopPropagation()\n        props.onFolderItemClick([props.folder.name])\n      }}\n    >\n      <Folder style={{ color: \"#fff\" }} />\n      {props.folder.name}\n    </li>\n  )\n}\n`}</code></pre>\n    <p>{`Here, we can see the when someone clicks on the component an `}<inlineCode parentName=\"p\">{`onFolderItemClick`}</inlineCode>{` function is fired which is having folder name as an array.\nWe will find out soon why we are passing it as an array.`}</p>\n    <p>{`Now it is the time for the `}<inlineCode parentName=\"p\">{`AccodionComponent`}</inlineCode>{`. It looks like this for now.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-jsx\"\n      }}>{`import React from \"react\"\n\nfunction Accordion(props) {\n  return (\n    <ul className=\"accordion\">\n      {Object.values(props.files).map(file => {\n        if (file.dir) {\n          return (\n            <AccordionFolderItem\n              key={file.name}\n              folder={file}\n              onFolderItemClick={folderPath => {\n                props.onFolderItemClick(folderPath)\n              }}\n            />\n          )\n        }\n        return (\n          <AccordionFileItem\n            key={file.name}\n            file={file}\n            onFileItemClick={() => {\n              console.log(file.name)\n            }}\n          />\n        )\n      })}\n    </ul>\n  )\n}\n`}</code></pre>\n    <p>{`This is how we are going to use it now.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-jsx\"\n      }}>{`import { update, cloneDeep } from \"lodash\"\n\nfunction loadContentForFolder(files, path) {\n  const subFiles = getFolderContents(path.join(\"/\"));\n  const newFiles = cloneDeep(files)\n\n  update(newFiles, path, function (n) {\n    return {\n      ...n,\n      files: subFiles,\n    }\n  })\n\n  return newFiles\n}\n\nfunction App() {\n  const [files, setFiles] = useState(getFolderContents(\"/\"))\n  function loadContents(path) {\n    const newFiles = loadContentForFolder(files, path)\n    setFiles(newFiles)\n  }\n\n  return (\n    <Accordion files={files} onFolderItemClick={path => loadContents(path)} />\n  )\n}\n`}</code></pre>\n    <p>{`The `}<inlineCode parentName=\"p\">{`loadContentForFolder`}</inlineCode>{` looks complicated. What it is doing is simple whenever you are loading contents of a folder it appends it to a files key in the folder object.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`// This is how our files will look like intially\n{\n  \"documents\":  { name: \"documents\", dir: true },\n  \"downloads\":   { name: \"downloads\", dir: true },\n  \"my.pptx\"      :   { name: \"my.pptx\", dir: false },\n}\n\nloadFiles(['documents'])\n\n// This is how files is going to look like after we load contents of documents folders.\n\n{\n  \"documents\":  {\n    name: \"documents\",\n    dir: true,\n    files: {\n      \"doc1.docx\": { name: \"doc1.docx\", dir: false },\n      \"pres.pptx\": { name: \"pres.pptx\", dir: false },\n    }\n  },\n  \"downloads\":   { name: \"downloads\", dir: true },\n  \"my.pptx\"      :   { name: \"my.pptx\", dir: false },\n}\n`}</code></pre>\n    <p>{`The problem here was this only worked for top level folders, ie, Whenever we try to load files of an inner folder like for eg. `}<inlineCode parentName=\"p\">{`downloads/music`}</inlineCode>{` it was\nadded to `}<inlineCode parentName=\"p\">{`{\"downloads\": {\"music\": \"...\" }}`}</inlineCode>{` but what we this data here `}<inlineCode parentName=\"p\">{`{\"downloads\": {\"files\": {\"music\": \"...\" }}}`}</inlineCode>{`. The easiest way is to update the\nwrite path from `}<inlineCode parentName=\"p\">{`[\"downloads\", \"documents\"]`}</inlineCode>{` to `}<inlineCode parentName=\"p\">{`[\"downloads\", \"files\", \"documents\"]`}</inlineCode>{`.`}</p>\n    <p>{`So our new `}<inlineCode parentName=\"p\">{`loadContentForFolder`}</inlineCode>{` function will look like this.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`function loadContentForFolder(files, path) {\n  const subFiles = getFolderContents(path.join(\"/\"));\n  const newFiles = cloneDeep(files);\n\n  const writePath = flatMap(path, (value, index, array) =>\n    array.length - 1 !== index ? [value, \"files\"] : value\n  );\n\n  update(newFiles, writePath, function (n) {\n    return {\n      ...n,\n      files: subFiles,\n    };\n  });\n\n  return newFiles;\n}\n`}</code></pre>\n    <p>{`Bit hacky, but works. Now our `}<inlineCode parentName=\"p\">{`loadContentForFolder`}</inlineCode>{` supports loading inner level folder contents. `}</p>\n    <p>{`Now we have to update the `}<inlineCode parentName=\"p\">{`AccordionFolderItem`}</inlineCode>{` component to show its sub files.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-jsx\"\n      }}>{`function AccordionFolderItem(props) {\n  return (\n    <li\n      className={\\`accordion__item accordion__item--folder \\${\n        props.isOpen ? \"accordion__item--open\" : \"\"\n      }\\`}\n      onClick={(e) => {\n        e.stopPropagation();\n        props.onFolderItemClick([props.folder.name]);\n      }}\n    >\n      <Folder style={{ color: \"#fff\" }} />\n      {props.folder.name}\n      {props.folder.files && (\n        <Accordion\n          files={props.folder.files}\n          onFolderItemClick={(path) =>\n            props.onFolderItemClick([props.folder.name, ...path])\n          }\n        />\n      )}\n    </li>\n  );\n}\n`}</code></pre>\n    <p>{`Now we have a recursive `}<inlineCode parentName=\"p\">{`Accordion`}</inlineCode>{` component. We have to make some adjustments in `}<inlineCode parentName=\"p\">{`Accordion`}</inlineCode>{` component to handle folder open and close.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-jsx\"\n      }}>{`function isFolderOpen(openFolders, folderName) {\n  return openFolders.find((f) => f === folderName);\n}\n\nfunction Accordion(props) {\n  const [openFolders, setOpenFolders] = useState([]);\n  function openCloseFolder(folder) {\n    const isOpen = isFolderOpen(openFolders, folder);\n    if (isOpen) {\n      setOpenFolders(openFolders.filter((f) => f !== folder));\n    } else {\n      setOpenFolders([...openFolders, folder]);\n    }\n  }\n  return (\n    <ul className=\"accordion\">\n      {Object.values(props.files).map((file) => {\n        if (file.dir) {\n          return (\n            <AccordionFolderItem\n              key={file.name}\n              file={file}\n              onFolderItemClick={(fileData) => {\n                const isOpen = isFolderOpen(openFolders, file.name);\n                if (!isOpen || fileData.length !== 1) {\n                  props.onFolderItemClick(fileData);\n                }\n                if (fileData.length === 1) {\n                  openCloseFolder(file.name);\n                }\n              }}\n              isOpen={isFolderOpen(openFolders, file.name)}\n            />\n          );\n        }\n        return (\n          <AccordionFileItem\n            key={file.name}\n            file={file}\n            onFileItemClick={() => {\n              console.log(file.name);\n            }}\n          />\n        );\n      })}\n    </ul>\n  );\n`}</code></pre>\n    <AccordionExample mdxType=\"AccordionExample\" />\n    <p>{`Now everything works perfect and we have a dynamic folder tree. This is just an intial version and We need make some adjustments to make it production ready.\nThanks for reading.`}</p>\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      "],"sourceRoot":""}