(window.webpackJsonp=window.webpackJsonp||[]).push([[6],{djht:function(e,n,o){"use strict";o.r(n),o.d(n,"_frontmatter",(function(){return r})),o.d(n,"default",(function(){return d}));var t=o("zLVn"),i=(o("q1tI"),o("7ljp")),a=o("Tqsq"),l=o("FV5N"),r={},s={_frontmatter:r},c=a.a;function d(e){var n=e.components,o=Object(t.a)(e,["components"]);return Object(i.b)(c,Object.assign({},s,o,{components:n,mdxType:"MDXLayout"}),Object(i.b)("p",null,"Recently I got a requirement for creating a folder tree in clojurescript which is dynamic that means we have to load the folder contents\ndynamically from an api when it is opened. I am going to explain how I did an initial version of it in javascript with React."),Object(i.b)("p",null,"I started with a sample data in the structure I get. Also wrote a wrapper function which returns the folder contents when a directory is passed.\nIt look like this."),Object(i.b)("pre",null,Object(i.b)("code",Object.assign({parentName:"pre"},{className:"language-javascript"}),'const folder = {\n  "/": [\n    { name: "documents", dir: true },\n    { name: "downloads", dir: true },\n    { name: "my.pptx", dir: false },\n  ],\n  documents: [\n    { name: "doc1.docx", dir: false },\n    { name: "pres.pptx", dir: false },\n  ],\n  downloads: [\n    { name: "music", dir: true },\n    { name: "file1.csv", dir: false },\n    { name: "file2.txt", dir: false },\n  ],\n  "downloads/music": [\n    { name: "doc1.docx", dir: false },\n    { name: "pres.pptx", dir: false },\n  ],\n}\n\nexport default function getFolderContents(directory) {\n  return folder[directory].reduce((acc, cur) => {\n    acc[cur.name] = cur\n    return acc\n  }, {})\n}\n')),Object(i.b)("p",null,"My ",Object(i.b)("inlineCode",{parentName:"p"},"getFiles")," function looks wierd this is because I wanted it in a tree like structure that way I can update it easily with lodash ",Object(i.b)("inlineCode",{parentName:"p"},"update")," function."),Object(i.b)("pre",null,Object(i.b)("code",Object.assign({parentName:"pre"},{className:"language-javascript"}),'/* This is what getFiles returns when \'/\' is passed as directory */\n\n{\n  "documents":  { name: "documents", dir: true },\n  "downloads":   { name: "downloads", dir: true },\n  "my.pptx"      :   { name: "my.pptx", dir: false },\n}\n')),Object(i.b)("p",null,"Another reason why I went for this format is it is easier for me when I convert this to clojurescript."),Object(i.b)("p",null,"Now I searched for some of the existing implementations of this feature and I could find a ",Object(i.b)("a",Object.assign({parentName:"p"},{href:"https://codyhouse.co/demo/multi-level-accordion-menu/index.html"}),"similar one")," that suits my need. It was a css and vanila js\nimplementation. I decided to create a React component similar to it."),Object(i.b)("p",null,"I had experience building accordion components. This new component works similar to accordion except that in this case there will be accordions inside accordion.\nSo, I started with an accordion component similar to what I did earlier. Also I have created accordion item component for files and folders."),Object(i.b)("p",null,"This is how my ",Object(i.b)("inlineCode",{parentName:"p"},"AccordionFileItem")," component looks like. It is just a list item with an icon and a file name."),Object(i.b)("pre",null,Object(i.b)("code",Object.assign({parentName:"pre"},{className:"language-jsx"}),'import React from "react"\nimport { Description } from "@material-ui/icons"\n\nfunction AccordionFileItem(props) {\n  return (\n    <li\n      className="accordion__item"\n      onClick={e => {\n        e.stopPropagation()\n        props.onFileItemClick()\n      }}\n    >\n      <Description style={{ color: "#fff" }} />\n      {props.file.name}\n    </li>\n  )\n}\n')),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"AccordionFolderItem")," was not straight forward because it will be having sub folders and files. I started with a folder item similar to\nfile item."),Object(i.b)("pre",null,Object(i.b)("code",Object.assign({parentName:"pre"},{className:"language-jsx"}),'import React from "react"\nimport { Description } from "@material-ui/icons"\n\nfunction AccordionFolderItem(props) {\n  return (\n    <li\n      className="accordion__item accordion__item--folder"\n      onClick={e => {\n        e.stopPropagation()\n        props.onFolderItemClick([props.folder.name])\n      }}\n    >\n      <Folder style={{ color: "#fff" }} />\n      {props.folder.name}\n    </li>\n  )\n}\n')),Object(i.b)("p",null,"Here, we can see the when someone clicks on the component an ",Object(i.b)("inlineCode",{parentName:"p"},"onFolderItemClick")," function is fired which is having folder name as an array.\nWe will find out soon why we are passing it as an array."),Object(i.b)("p",null,"Now it is the time for the ",Object(i.b)("inlineCode",{parentName:"p"},"AccodionComponent"),". It looks like this for now."),Object(i.b)("pre",null,Object(i.b)("code",Object.assign({parentName:"pre"},{className:"language-jsx"}),'import React from "react"\n\nfunction Accordion(props) {\n  return (\n    <ul className="accordion">\n      {Object.values(props.files).map(file => {\n        if (file.dir) {\n          return (\n            <AccordionFolderItem\n              key={file.name}\n              folder={file}\n              onFolderItemClick={folderPath => {\n                props.onFolderItemClick(folderPath)\n              }}\n            />\n          )\n        }\n        return (\n          <AccordionFileItem\n            key={file.name}\n            file={file}\n            onFileItemClick={() => {\n              console.log(file.name)\n            }}\n          />\n        )\n      })}\n    </ul>\n  )\n}\n')),Object(i.b)("p",null,"This is how we are going to use it now."),Object(i.b)("pre",null,Object(i.b)("code",Object.assign({parentName:"pre"},{className:"language-jsx"}),'import { update, cloneDeep } from "lodash"\n\nfunction loadContentForFolder(files, path) {\n  const subFiles = getFolderContents(path.join("/"));\n  const newFiles = cloneDeep(files)\n\n  update(newFiles, path, function (n) {\n    return {\n      ...n,\n      files: subFiles,\n    }\n  })\n\n  return newFiles\n}\n\nfunction App() {\n  const [files, setFiles] = useState(getFolderContents("/"))\n  function loadContents(path) {\n    const newFiles = loadContentForFolder(files, path)\n    setFiles(newFiles)\n  }\n\n  return (\n    <Accordion files={files} onFolderItemClick={path => loadContents(path)} />\n  )\n}\n')),Object(i.b)("p",null,"The ",Object(i.b)("inlineCode",{parentName:"p"},"loadContentForFolder")," looks complicated. What it is doing is simple whenever you are loading contents of a folder it appends it to a files key in the folder object."),Object(i.b)("pre",null,Object(i.b)("code",Object.assign({parentName:"pre"},{className:"language-javascript"}),'// This is how our files will look like intially\n{\n  "documents":  { name: "documents", dir: true },\n  "downloads":   { name: "downloads", dir: true },\n  "my.pptx"      :   { name: "my.pptx", dir: false },\n}\n\nloadFiles([\'documents\'])\n\n// This is how files is going to look like after we load contents of documents folders.\n\n{\n  "documents":  {\n    name: "documents",\n    dir: true,\n    files: {\n      "doc1.docx": { name: "doc1.docx", dir: false },\n      "pres.pptx": { name: "pres.pptx", dir: false },\n    }\n  },\n  "downloads":   { name: "downloads", dir: true },\n  "my.pptx"      :   { name: "my.pptx", dir: false },\n}\n')),Object(i.b)("p",null,"The problem here was this only worked for top level folders, ie, Whenever we try to load files of an inner folder like for eg. ",Object(i.b)("inlineCode",{parentName:"p"},"downloads/music")," it was\nadded to ",Object(i.b)("inlineCode",{parentName:"p"},'{"downloads": {"music": "..." }}')," but what we this data here ",Object(i.b)("inlineCode",{parentName:"p"},'{"downloads": {"files": {"music": "..." }}}'),". The easiest way is to update the\nwrite path from ",Object(i.b)("inlineCode",{parentName:"p"},'["downloads", "documents"]')," to ",Object(i.b)("inlineCode",{parentName:"p"},'["downloads", "files", "documents"]'),"."),Object(i.b)("p",null,"So our new ",Object(i.b)("inlineCode",{parentName:"p"},"loadContentForFolder")," function will look like this."),Object(i.b)("pre",null,Object(i.b)("code",Object.assign({parentName:"pre"},{className:"language-javascript"}),'function loadContentForFolder(files, path) {\n  const subFiles = getFolderContents(path.join("/"));\n  const newFiles = cloneDeep(files);\n\n  const writePath = flatMap(path, (value, index, array) =>\n    array.length - 1 !== index ? [value, "files"] : value\n  );\n\n  update(newFiles, writePath, function (n) {\n    return {\n      ...n,\n      files: subFiles,\n    };\n  });\n\n  return newFiles;\n}\n')),Object(i.b)("p",null,"Bit hacky, but works. Now our ",Object(i.b)("inlineCode",{parentName:"p"},"loadContentForFolder")," supports loading inner level folder contents. "),Object(i.b)("p",null,"Now we have to update the ",Object(i.b)("inlineCode",{parentName:"p"},"AccordionFolderItem")," component to show its sub files."),Object(i.b)("pre",null,Object(i.b)("code",Object.assign({parentName:"pre"},{className:"language-jsx"}),'function AccordionFolderItem(props) {\n  return (\n    <li\n      className={`accordion__item accordion__item--folder ${\n        props.isOpen ? "accordion__item--open" : ""\n      }`}\n      onClick={(e) => {\n        e.stopPropagation();\n        props.onFolderItemClick([props.folder.name]);\n      }}\n    >\n      <Folder style={{ color: "#fff" }} />\n      {props.folder.name}\n      {props.folder.files && (\n        <Accordion\n          files={props.folder.files}\n          onFolderItemClick={(path) =>\n            props.onFolderItemClick([props.folder.name, ...path])\n          }\n        />\n      )}\n    </li>\n  );\n}\n')),Object(i.b)("p",null,"Now we have a recursive ",Object(i.b)("inlineCode",{parentName:"p"},"Accordion")," component. We have to make some adjustments in ",Object(i.b)("inlineCode",{parentName:"p"},"Accordion")," component to handle folder open and close."),Object(i.b)("pre",null,Object(i.b)("code",Object.assign({parentName:"pre"},{className:"language-jsx"}),'function isFolderOpen(openFolders, folderName) {\n  return openFolders.find((f) => f === folderName);\n}\n\nfunction Accordion(props) {\n  const [openFolders, setOpenFolders] = useState([]);\n  function openCloseFolder(folder) {\n    const isOpen = isFolderOpen(openFolders, folder);\n    if (isOpen) {\n      setOpenFolders(openFolders.filter((f) => f !== folder));\n    } else {\n      setOpenFolders([...openFolders, folder]);\n    }\n  }\n  return (\n    <ul className="accordion">\n      {Object.values(props.files).map((file) => {\n        if (file.dir) {\n          return (\n            <AccordionFolderItem\n              key={file.name}\n              file={file}\n              onFolderItemClick={(fileData) => {\n                const isOpen = isFolderOpen(openFolders, file.name);\n                if (!isOpen || fileData.length !== 1) {\n                  props.onFolderItemClick(fileData);\n                }\n                if (fileData.length === 1) {\n                  openCloseFolder(file.name);\n                }\n              }}\n              isOpen={isFolderOpen(openFolders, file.name)}\n            />\n          );\n        }\n        return (\n          <AccordionFileItem\n            key={file.name}\n            file={file}\n            onFileItemClick={() => {\n              console.log(file.name);\n            }}\n          />\n        );\n      })}\n    </ul>\n  );\n')),Object(i.b)(l.a,{mdxType:"AccordionExample"}),Object(i.b)("p",null,"Now everything works perfect and we have a dynamic folder tree. This is just an intial version and We need make some adjustments to make it production ready.\nThanks for reading."))}d.isMDXComponent=!0}}]);
//# sourceMappingURL=component---src-pages-blog-posts-11-2020-react-dynamic-folder-tree-mdx-b08732f8fdc65d9e75ea.js.map